import os
import logging
import tempfile
from flask import Flask, request, jsonify
import cv2
import numpy as np
from telegram import Bot, Update
from telegram.error import TelegramError
import requests

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
TOKEN = os.environ.get('TELEGRAM_BOT_TOKEN')
WEBHOOK_URL = os.environ.get('WEBHOOK_URL')
PORT = int(os.environ.get('PORT', 5000))

app = Flask(__name__)

def create_beer_mug():
    """–°–æ–∑–¥–∞–µ—Ç –∫—Ä—É–∂–∫—É –ø–∏–≤–∞ —Å –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–º —Ñ–æ–Ω–æ–º"""
    size = 200
    # –°–æ–∑–¥–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å –∞–ª—å—Ñ–∞-–∫–∞–Ω–∞–ª–æ–º
    beer_mug = np.zeros((size, size, 4), dtype=np.uint8)
    
    # –û—Å–Ω–æ–≤–Ω–∞—è —á–∞—Å—Ç—å –∫—Ä—É–∂–∫–∏ (—è–Ω—Ç–∞—Ä–Ω—ã–π —Ü–≤–µ—Ç)
    cv2.rectangle(beer_mug, (60, 50), (140, 180), (50, 100, 200, 255), -1)
    
    # –ü–µ–Ω–∞
    cv2.rectangle(beer_mug, (60, 30), (140, 60), (255, 255, 255, 255), -1)
    cv2.ellipse(beer_mug, (100, 30), (40, 20), 0, 0, 360, (255, 255, 255, 255), -1)
    
    # –†—É—á–∫–∞
    cv2.ellipse(beer_mug, (150, 120), (25, 40), 0, 270, 90, (100, 70, 30, 255), -1)
    
    # –û–±–æ–¥–æ–∫
    cv2.rectangle(beer_mug, (55, 45), (145, 55), (100, 70, 30, 255), -1)
    cv2.rectangle(beer_mug, (55, 175), (145, 185), (100, 70, 30, 255), -1)
    
    return beer_mug

def add_beer_to_image(input_path, output_path):
    """–î–æ–±–∞–≤–ª—è–µ—Ç –∫—Ä—É–∂–∫—É –ø–∏–≤–∞ –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ"""
    try:
        logger.info("Starting image processing")
        
        # –ß–∏—Ç–∞–µ–º –∏—Å—Ö–æ–¥–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
        original_image = cv2.imread(input_path)
        if original_image is None:
            logger.error("Failed to read input image")
            return False
        
        # –°–æ–∑–¥–∞–µ–º –∫—Ä—É–∂–∫—É –ø–∏–≤–∞
        beer_mug = create_beer_mug()
        
        # –ü–æ–ª—É—á–∞–µ–º —Ä–∞–∑–º–µ—Ä—ã
        img_height, img_width = original_image.shape[:2]
        beer_height, beer_width = beer_mug.shape[:2]
        
        # –í—ã—á–∏—Å–ª—è–µ–º —Ä–∞–∑–º–µ—Ä –∫—Ä—É–∂–∫–∏ (20% –æ—Ç –º–µ–Ω—å—à–µ–π —Å—Ç–æ—Ä–æ–Ω—ã –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è)
        scale = min(img_width, img_height) * 0.2 / beer_width
        new_width = int(beer_width * scale)
        new_height = int(beer_height * scale)
        
        # –ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º –∫—Ä—É–∂–∫—É
        beer_mug_resized = cv2.resize(beer_mug, (new_width, new_height))
        
        # –ü–æ–∑–∏—Ü–∏—è –≤ –ø—Ä–∞–≤–æ–º –Ω–∏–∂–Ω–µ–º —É–≥–ª—É —Å –æ—Ç—Å—Ç—É–ø–æ–º
        x_pos = img_width - new_width - 20
        y_pos = img_height - new_height - 20
        
        # –û–±–µ—Å–ø–µ—á–∏–≤–∞–µ–º, —á—Ç–æ–±—ã –ø–æ–∑–∏—Ü–∏—è –±—ã–ª–∞ –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
        x_pos = max(0, min(x_pos, img_width - new_width))
        y_pos = max(0, min(y_pos, img_height - new_height))
        
        logger.info(f"Image size: {img_width}x{img_height}, Beer size: {new_width}x{new_height}, Position: ({x_pos}, {y_pos})")
        
        # –ù–∞–∫–ª–∞–¥—ã–≤–∞–µ–º –∫—Ä—É–∂–∫—É —Å —É—á–µ—Ç–æ–º –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏
        for y in range(new_height):
            for x in range(new_width):
                if y + y_pos < img_height and x + x_pos < img_width:
                    alpha = beer_mug_resized[y, x, 3] / 255.0  # –ê–ª—å—Ñ–∞-–∫–∞–Ω–∞–ª
                    if alpha > 0:  # –ï—Å–ª–∏ –ø–∏–∫—Å–µ–ª—å –Ω–µ –ø–æ–ª–Ω–æ—Å—Ç—å—é –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π
                        for channel in range(3):  # RGB –∫–∞–Ω–∞–ª—ã
                            original_image[y + y_pos, x + x_pos, channel] = (
                                alpha * beer_mug_resized[y, x, channel] +
                                (1 - alpha) * original_image[y + y_pos, x + x_pos, channel]
                            )
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        success = cv2.imwrite(output_path, original_image)
        logger.info(f"Image saved: {success}")
        
        return success
        
    except Exception as e:
        logger.error(f"Error in add_beer_to_image: {str(e)}")
        return False

def download_file(url, local_path):
    """–°–∫–∞—á–∏–≤–∞–µ—Ç —Ñ–∞–π–ª –ø–æ URL"""
    try:
        response = requests.get(url, stream=True)
        response.raise_for_status()
        
        with open(local_path, 'wb') as f:
            for chunk in response.iter_content(chunk_size=8192):
                f.write(chunk)
        return True
    except Exception as e:
        logger.error(f"Error downloading file: {str(e)}")
        return False

@app.route('/')
def home():
    logger.info("Home page accessed")
    return jsonify({
        "status": "running",
        "service": "Beer Bot",
        "version": "1.0"
    })

@app.route('/health')
def health():
    return jsonify({"status": "healthy"})

@app.route('/webhook', methods=['POST'])
def webhook():
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤–µ–±—Ö—É–∫–∞ –æ—Ç Telegram"""
    try:
        logger.info("Webhook received")
        
        if not TOKEN:
            logger.error("TELEGRAM_BOT_TOKEN not set")
            return "ERROR: Token not configured", 500
        
        # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ—Ç Telegram
        update_data = request.get_json()
        logger.info(f"Update data: {update_data}")
        
        if not update_data:
            logger.error("No data in webhook")
            return "ERROR: No data", 400
        
        update = Update.de_json(update_data, Bot(TOKEN))
        
        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å —Ñ–æ—Ç–æ
        if update.message and update.message.photo:
            process_telegram_photo(update.message)
        elif update.message and update.message.text:
            process_telegram_text(update.message)
        
        return "OK"
        
    except Exception as e:
        logger.error(f"Webhook error: {str(e)}")
        return "ERROR", 500

def process_telegram_text(message):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π"""
    try:
        bot = Bot(TOKEN)
        chat_id = message.chat.id
        text = message.text.lower()
        
        if text in ['/start', '/help']:
            bot.send_message(
                chat_id=chat_id,
                text="üçª –ü—Ä–∏–≤–µ—Ç! –Ø Beer Bot! üçª\n\n–û—Ç–ø—Ä–∞–≤—å –º–Ω–µ —Ñ–æ—Ç–æ —á–µ–ª–æ–≤–µ–∫–∞ –∏–ª–∏ –∂–∏–≤–æ—Ç–Ω–æ–≥–æ, –∏ —è –¥–æ–±–∞–≤–ª—é –∫—Ä—É–∂–∫—É –ø–∏–≤–∞ –≤ —Ä—É–∫—É!\n\n–ü—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å –ª—é–±–æ–µ —Ñ–æ—Ç–æ –∏ —É–≤–∏–¥–∏—à—å –º–∞–≥–∏—é!"
            )
        else:
            bot.send_message(
                chat_id=chat_id,
                text="–û—Ç–ø—Ä–∞–≤—å –º–Ω–µ —Ñ–æ—Ç–æ, –∏ —è –¥–æ–±–∞–≤–ª—é –∫—Ä—É–∂–∫—É –ø–∏–≤–∞! üçª"
            )
            
    except Exception as e:
        logger.error(f"Error processing text: {str(e)}")

def process_telegram_photo(message):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–æ—Ç–æ –æ—Ç Telegram"""
    try:
        bot = Bot(TOKEN)
        chat_id = message.chat.id
        
        logger.info("Processing photo message")
        bot.send_message(chat_id, "üçª –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é —Ñ–æ—Ç–æ... –î–æ–±–∞–≤–ª—è—é –∫—Ä—É–∂–∫—É –ø–∏–≤–∞!")
        
        # –ë–µ—Ä–µ–º —Ñ–æ—Ç–æ –Ω–∞–∏–±–æ–ª—å—à–µ–≥–æ –∫–∞—á–µ—Å—Ç–≤–∞ (–ø–æ—Å–ª–µ–¥–Ω–µ–µ –≤ —Å–ø–∏—Å–∫–µ)
        photo = message.photo[-1]
        file_id = photo.file_id
        
        # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ñ–∞–π–ª–µ
        file_info = bot.get_file(file_id)
        file_url = file_info.file_path
        
        logger.info(f"File URL: {file_url}")
        
        # –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã
        with tempfile.NamedTemporaryFile(suffix='.jpg', delete=False) as input_file:
            input_path = input_file.name
        
        with tempfile.NamedTemporaryFile(suffix='.jpg', delete=False) as output_file:
            output_path = output_file.name
        
        try:
            # –°–∫–∞—á–∏–≤–∞–µ–º —Ñ–æ—Ç–æ
            download_success = download_file(f"https://api.telegram.org/file/bot{TOKEN}/{file_url}", input_path)
            
            if not download_success:
                bot.send_message(chat_id, "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–æ—Ç–æ")
                return
            
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
            processing_success = add_beer_to_image(input_path, output_path)
            
            if processing_success:
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–æ–µ —Ñ–æ—Ç–æ
                with open(output_path, 'rb') as photo_file:
                    bot.send_photo(
                        chat_id=chat_id,
                        photo=photo_file,
                        caption="üéâ –í–∞—à–µ —Ñ–æ—Ç–æ —Å –∫—Ä—É–∂–∫–æ–π –ø–∏–≤–∞! üçª"
                    )
                logger.info("Photo processed and sent successfully")
            else:
                bot.send_message(chat_id, "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å —Ñ–æ—Ç–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.")
                logger.error("Photo processing failed")
                
        finally:
            # –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã
            try:
                if os.path.exists(input_path):
                    os.unlink(input_path)
                if os.path.exists(output_path):
                    os.unlink(output_path)
            except Exception as e:
                logger.error(f"Error cleaning temp files: {str(e)}")
                
    except Exception as e:
        logger.error(f"Error processing photo: {str(e)}")
        try:
            bot.send_message(chat_id, "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–æ—Ç–æ")
        except:
            pass

@app.route('/set_webhook', methods=['GET'])
def set_webhook_route():
    """–£—Å—Ç–∞–Ω–æ–≤–∫–∞ –≤–µ–±—Ö—É–∫–∞"""
    try:
        if not TOKEN or not WEBHOOK_URL:
            return jsonify({
                "error": "TELEGRAM_BOT_TOKEN or WEBHOOK_URL not set",
                "token_set": bool(TOKEN),
                "webhook_url_set": bool(WEBHOOK_URL)
            }), 400
        
        bot = Bot(TOKEN)
        webhook_url = f"{WEBHOOK_URL}/webhook"
        
        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤–µ–±—Ö—É–∫
        result = bot.set_webhook(webhook_url)
        
        logger.info(f"Webhook set to: {webhook_url}, result: {result}")
        
        return jsonify({
            "status": "success",
            "webhook_url": webhook_url,
            "result": result
        })
        
    except Exception as e:
        logger.error(f"Error setting webhook: {str(e)}")
        return jsonify({"error": str(e)}), 500

@app.route('/remove_webhook', methods=['GET'])
def remove_webhook_route():
    """–£–¥–∞–ª–µ–Ω–∏–µ –≤–µ–±—Ö—É–∫–∞"""
    try:
        if not TOKEN:
            return jsonify({"error": "TELEGRAM_BOT_TOKEN not set"}), 400
        
        bot = Bot(TOKEN)
        result = bot.delete_webhook()
        
        logger.info(f"Webhook removed: {result}")
        
        return jsonify({
            "status": "success", 
            "result": result
        })
        
    except Exception as e:
        logger.error(f"Error removing webhook: {str(e)}")
        return jsonify({"error": str(e)}), 500

@app.route('/webhook_info', methods=['GET'])
def webhook_info():
    """–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –≤–µ–±—Ö—É–∫–µ"""
    try:
        if not TOKEN:
            return jsonify({"error": "TELEGRAM_BOT_TOKEN not set"}), 400
        
        bot = Bot(TOKEN)
        info = bot.get_webhook_info()
        
        return jsonify({
            "url": info.url,
            "has_custom_certificate": info.has_custom_certificate,
            "pending_update_count": info.pending_update_count,
            "last_error_date": info.last_error_date,
            "last_error_message": info.last_error_message
        })
        
    except Exception as e:
        logger.error(f"Error getting webhook info: {str(e)}")
        return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    logger.info(f"Starting Beer Bot on port {PORT}")
    logger.info(f"Token set: {bool(TOKEN)}")
    logger.info(f"Webhook URL: {WEBHOOK_URL}")
    
    app.run(host='0.0.0.0', port=PORT, debug=False)